snippet class
class ${1:ClassName} {
 private:
 public:
};
endsnippet

snippet struct
struct ${1:ClassName} {
 private:
 public:
};
endsnippet

snippet def "#define ..." b
#define ${1:METHOD}(${2:x}) ($2)
endsnippet

snippet ZCLASS "an prime field implementation"
/** DEFINE PRIME FIELD CLASS **/
struct ZZ {
	static constexpr long long MOD = ${1:1000000007LL};
	long long value;
	mutable long long cached_inv;
	ZZ(long long v=0) : value(v), cached_inv(-1) {
		ensure();
	}
	void ensure() {
		if (value < 0 || value >= MOD) {
			value %= MOD;
			value = (value + MOD) % MOD;
		}
	}
	void R() { scanf("%lld", &value); cached_inv = -1; }
	ZZ& operator += (const ZZ& o) {
		value += o.value;
		if (value >= MOD) value -= MOD;
		return *this;
	}
	ZZ& operator -= (const ZZ& o) {
		value -= o.value;
		if (value < 0) value += MOD;
		return *this;
	}
	ZZ& operator *= (const ZZ& o) {
		value *= o.value;
		value %= MOD;
		return *this;
	}
	ZZ& operator /= (const ZZ& o) {
		return (*this *= o.inv());
	}
	#define DEFOPT(opt) \
		ZZ operator opt (const ZZ& o) const { \
			ZZ x = *this; x opt##= o; return x; }
	DEFOPT(+)
	DEFOPT(-)
	DEFOPT(*)
	DEFOPT(/)
	#undef DEFOPT

	ZZ pow(int n) const {
		ZZ x = *this;
		ZZ r = 1;

		while (n > 0) {
			if (n & 1) { r *= x; }
			x *= x;
			n >>= 1;
		}
		return r;
	}

	ZZ inv() const {
		return cached_inv == -1 ? cached_inv = pow(MOD - 2).value : cached_inv;
	}
};
inline void read_this(ZZ&z) {read_this(z.value);}
/** END OF ZZ **/
$0
endsnippet

snippet HEADERS "for coding contests" b
/** HEADER FOR CODING CONTESTS **/
#include <vector>
#include <cstdio>
#include <map>
#include <set>
#include <algorithm>
#include <tuple>
#include <cassert>

typedef long long LL;
typedef unsigned long long ULL;

#define V vector
#define RI(x, ...) read_these(x, ##__VA_ARGS__)
#define RV(v) read_these(v)
#define RNP(n, p) read_these(n,p)
inline void read_this(int&v){scanf("%d",&v);}
inline void read_this(unsigned int&v){scanf("%u",&v);}
inline void read_this(long long&v){scanf("%lld",&v);}
inline void read_this(unsigned long long&v){scanf("%llu",&v);}
inline void read_these(){}
template <typename T, typename...Ts>
inline void read_these(T&v,Ts&... vs){read_this(v);read_these(vs...);}
template <typename T>
inline void read_these(std::vector<T>&vs){for(auto&v:vs)read_this(v);}
template<typename T>
inline void read_these(size_t n,T*vs){for(size_t i=0;i<n;++i)read_this(vs[i]);}
/** END OF HEADER **/
$0
endsnippet

snippet BIT "binary indexed tree"
template<typename T>
struct BinaryIndexedTree {
  /**
   * let p = max {q s.t. ((2^q - 1) & i) == 2^q - 1}
   *
   * value[i] = arr[i - 2^p - 1] + ... + arr[i]
   *
   * ex:
   *  value[0] = arr[0]
   *  value[1] = arr[0] + arr[1]
   *  value[2] = arr[0]
   *  value[3] = arr[0] + arr[1] + arr[2] + arr[3]
   */
  vector<T> value;
  void init(int n) {
    value.clear();
    value.resize(n, 0);
  }
  /**
   * returns arr[0] + ... + arr[i]
   */
  T query(int i) const {
    T sum = 0;
    for (; i >= 0; -- i) {
      sum += value[i];
      i &= (i + 1);
    }
    return sum;
  }
  T query(int i, int j) const {
    return query(j) - query(i - 1);
  }
  /**
   * arr[i] += delta
   */
  void add(int i, T delta) {
    for (; i < (int) value.size();) {
      value[i] += delta;
      i |= (i + 1);
    }
  }
};
endsnippet

snippet LINKCUT "link-cut tree"
struct LinkCutTree {
  struct Node {
    static vector<Node> node_pool;
    static size_t node_pool_tail;
    static Node* get_new_node() {
      if (node_pool_tail >= node_pool.size()) {
        exit(0);
      }
      return &node_pool[node_pool_tail ++];
    }
    static void reset_node_pool() {
      node_pool_tail = 0;
    }
    Node* parent;
    Node* path_parent;
    Node* l_child;
    Node* r_child;

#define DEF(type, name) type SPLAY_##name; type MY_##name;
#define SPLAY(name) SPLAY_##name // the sum of MY(name) in same splay tree
#define MY(name) MY_##name
    DEF(LL, size); // sum of SPLAY(size) of nodes v, s.t. v.path_parent = this
    DEF(LL, cost); // sum of SPLAY(cost) of nodes v, s.t. v.path_parent = this
    DEF(LL, dv);   // my->value - parent->value in rep. tree
    Node* init(LL value) {
      MY(cost) = 0;
      MY(size) = 1;
      MY(dv) = value;
      l_child = r_child = parent = path_parent = nullptr;
      update();
      return this;
    }
    bool is_root() const {
      return parent == nullptr;
    }
    LL total_cost() const {
      auto v = MY(dv);
      if (l_child != nullptr) {
        v += l_child->SPLAY(dv);
      }
      auto s = MY(size);
      if (r_child != nullptr) {
        s += r_child->SPLAY(size);
      }
      return SPLAY(cost) + v * s;
    }
    void update() {
      SPLAY(size) = MY(size);
      SPLAY(cost) = MY(cost);
      SPLAY(dv) = MY(dv);
      if (l_child != nullptr) {
        SPLAY(size) += l_child->SPLAY(size);
        SPLAY(cost) += l_child->total_cost();
        SPLAY(dv) += l_child->SPLAY(dv);
      }
      if (r_child != nullptr) {
        SPLAY(size) += r_child->SPLAY(size);
        SPLAY(cost) += r_child->total_cost();
        SPLAY(dv) += r_child->SPLAY(dv);
      }
    }
    // move this move upward
    void rotate() {
      if (parent == nullptr) {
        return;
      }
      auto p = parent;
      auto g = p->parent;
      if (p->is_root()) {
        path_parent = p->path_parent;
        p->path_parent = nullptr;
        parent = nullptr;
      } else {
        if (p == g->l_child) {
          g->set_l_child(this);
        } else if (p == g->r_child) {
          g->set_r_child(this);
        }
      }
      if (this == p->l_child) {
        p->set_l_child(r_child);
        set_r_child(p);
      } else if (this == p->r_child) {
        p->set_r_child(l_child);
        set_l_child(p);
      }
      p->update();
      update();
    }
    void set_l_child(Node* x) {
      l_child = x;
      if (x != nullptr) {
        x->parent = this;
      }
    }
    void set_r_child(Node* x) {
      r_child = x;
      if (x != nullptr) {
        x->parent = this;
      }
    }
  };
  void splay(Node* x) {
    while (x->parent != nullptr) {
      x->rotate();
    }
  }
  void separate_r_child(Node* x) {
    if (x->r_child != nullptr) {
      auto r = x->r_child;
      x->r_child->path_parent = x;
      x->r_child->parent = nullptr;
      x->r_child = nullptr;
      x->MY(size) += r->SPLAY(size);
      x->MY(cost) += r->total_cost();
      x->update();
    }
  }
  void append_r_child(Node* x, Node* r) {
    if (x->r_child != nullptr) {
      exit (0);
    }
    x->r_child = r;
    r->parent = x;
    r->path_parent = nullptr;
    x->MY(size) -= r->SPLAY(size);
    x->MY(cost) -= r->total_cost();
    x->update();
  }
  void access(Node* x) {
    splay(x);
    separate_r_child(x);
    while (x->path_parent != nullptr) {
      auto pp = x->path_parent;
      splay(pp);
      separate_r_child(pp);
      append_r_child(pp, x);
      x->rotate();
    }
  }
  // make v a child of p
  void link(Node* v, Node* p) {
    access(p);
    access(v);
    v->set_l_child(p);
    auto pv = p->SPLAY(dv); // the value of p
    v->MY(dv) -= pv;
    v->update();
  }
  void cut(Node* v) {
    access(v);
    auto l = v->l_child;
    if (l != nullptr) {
      v->l_child = nullptr;
      l->parent = nullptr;
    }
    v->update();
  }
  LL query(Node* x) {
    access(x);
    LL w = x->MY(dv);
    if (x->l_child != nullptr) {
      w += x->l_child->SPLAY(dv);
    }
    return x->MY(cost) + x->MY(size) * w;
  }
  LinkCutTree() { }
  void solve() {
    int n, m;
    RI(n);
    vector<LL> vs(n);
    RV(vs);
    Node::reset_node_pool();
    vector<Node*> nodes(n);
    nodes.reserve(300000);
    for (auto i = 0; i < n; ++ i) {
      nodes[i] = Node::get_new_node()->init(vs[i]);
    }
    for (auto i = 0; i < n - 1; ++ i) {
      int p, v;
      RI(p); RI(v);
      link(nodes[v], nodes[p]);
    }
    RI(m);
    LL special = 0;
    while (m --) {
      int type;
      LL key, value;
      RI(type, key);
      if (special + key >= (LL) nodes.size() || special + key < 0) {
        exit(0);
      }
      auto v = nodes[special + key];
      switch (type) {
        case 1:
          RI(value);
          nodes.push_back(Node::get_new_node()->init(value));
          link(nodes.back(), v);
          break;
        case 2:
          RI(value);
          access(v);
          v->MY(dv) += value;
          v->update();
          break;
        case 3:
          cut(v);
          break;
        case 4:
          special = query(v);
          printf("%lld\n", special);
          break;
      }
    }
  }
};
typedef typename LinkCutTree::Node Node;
vector<Node> Node::node_pool{300000};
size_t Node::node_pool_tail = 0;
endsnippet
